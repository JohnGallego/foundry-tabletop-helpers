name: Release

on:
  push:
    tags:
      - "v*.*.*"

jobs:
  build-and-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write    # needed for pushing to main and creating releases
    env:
      FOUNDRY_RELEASE_TOKEN: ${{ secrets.FOUNDRY_RELEASE_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure tag commit is on main
        run: |
          git fetch origin main
          if ! git merge-base --is-ancestor "$GITHUB_SHA" origin/main; then
            echo "❌ Tag commit is NOT on main. Aborting."
            exit 1
          fi
          echo "✅ Tag is on main."

      - name: Sync package.json version to tag
        run: |
          TAG_VER="${GITHUB_REF_NAME#v}"
          node -e "const fs=require('fs');const p='package.json';const pkg=JSON.parse(fs.readFileSync(p,'utf8'));pkg.version='${TAG_VER}';fs.writeFileSync(p, JSON.stringify(pkg,null,2)+'\n');"
          cat package.json | sed -n '1,25p'

      - name: Commit package.json version (to main)
        run: |
          if ! git diff --quiet -- package.json; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add package.json
            git commit -m "chore: set package.json version to ${GITHUB_REF_NAME#v}"
            git push origin HEAD:main
          fi


      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install deps
        run: npm ci

      - name: Build
        run: npm run build

      # Make manifest URLs tag-specific so installs are reproducible.
      - name: Stamp manifest URLs to tag
        run: |
          TAG="${GITHUB_REF_NAME}"
          OWNER="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          # dist/module.json must already exist from your build script
          jq --arg tag "$TAG" --arg owner "$OWNER" --arg repo "$REPO" '
            .manifest = "https://raw.githubusercontent.com/\($owner)/\($repo)/main/module.json" |
            .download = "https://github.com/\($owner)/\($repo)/releases/download/\($tag)/\($repo)-\($tag).zip"
          ' dist/module.json > dist/module.json.tmp
          mv dist/module.json.tmp dist/module.json
          cat dist/module.json

      - name: Create zip artifact
        run: |
          ZIP_NAME="${{ github.event.repository.name }}-${GITHUB_REF_NAME}.zip"
          cd dist
          zip -r "../${ZIP_NAME}" .
          cd ..
          sha256sum "${ZIP_NAME}" > "${ZIP_NAME}.sha256"

      # Sync dist/module.json back to repo root and commit to main
      - name: Sync root module.json (commit to main)
        run: |
          cp dist/module.json module.json
          if ! git diff --quiet -- module.json; then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git add module.json
            git commit -m "chore: sync module.json for ${GITHUB_REF_NAME}"
            git push origin HEAD:main
            echo "✅ Pushed updated module.json to main."
          else
            echo "ℹ️ module.json unchanged; nothing to push."
          fi

      - name: Publish GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          generate_release_notes: true
          files: |
            ${{ github.event.repository.name }}-${{ github.ref_name }}.zip
            ${{ github.event.repository.name }}-${{ github.ref_name }}.zip.sha256
            dist/module.json


      - name: Publish to Foundry Package Release API
        if: ${{ env.FOUNDRY_RELEASE_TOKEN != '' }}
        env:
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          TAG: ${{ github.ref_name }}
          TOKEN: ${{ env.FOUNDRY_RELEASE_TOKEN }}
        run: |
          set -euo pipefail
          ID="$(jq -r '.id' dist/module.json)"
          MIN="$(jq -r '.compatibility.minimum' dist/module.json)"
          VER="$(jq -r '.compatibility.verified' dist/module.json)"
          MAX="$(jq -r '.compatibility.maximum // empty' dist/module.json)"
          VERSION="${TAG#v}"
          MANIFEST_URL="https://github.com/${OWNER}/${REPO}/releases/download/${TAG}/module.json"
          NOTES_URL="https://github.com/${OWNER}/${REPO}/releases/tag/${TAG}"

          echo "Submitting release to Foundry for package '${ID}' version '${VERSION}'"

          payload=$(jq -n \
            --arg id "$ID" \
            --arg version "$VERSION" \
            --arg manifest "$MANIFEST_URL" \
            --arg notes "$NOTES_URL" \
            --arg minimum "$MIN" \
            --arg verified "$VER" \
            --arg maximum "${MAX:-}" \
            '{
              id: $id,
              release: {
                version: $version,
                manifest: $manifest,
                notes: $notes,
                compatibility: (if $maximum == "" then
                  { minimum: $minimum, verified: $verified }
                else
                  { minimum: $minimum, verified: $verified, maximum: $maximum }
                end)
              }
            }')

          echo "$payload" | jq .

          HTTP_STATUS=$(curl -sS -X POST "https://foundryvtt.com/_api/packages/release_version/" \
            -H "Content-Type: application/json" \
            -H "Authorization: ${TOKEN}" \
            -d @"-" \
            -o response.json \
            -w "%{http_code}" <<< "$payload")

          echo "Response ($HTTP_STATUS):"
          cat response.json && echo

          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Failed to publish to Foundry Package Release API (HTTP $HTTP_STATUS)"
            exit 1
          fi
